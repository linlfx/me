并发编程时，必须考虑安全性问题，即线程安全，所谓线程安全就是可以同时被多个线程调用，调用者无须额外的操作，程序也不会出现错误的结果。
要使程序是线程安全的，必须考虑以下2点：
1. 是否存在竞态条件，常见的是那些先检查后执行的操作行为，它的正确结果取决于运气。避免错误结果的方法是保证操作的原子性，通常使用加锁，也有一些原子变量类可以达到目的。
2. 对象状态在内存中是否可见，即当一个线程修改了对象的状态后，其他线程不一定看到修改后的状态。保证其他线程总是能看到最新状态的方法有2种：一种是加锁，另一种是使用volatile变量。

于是得出几个结论：
1. 加锁机制可保证可见性和原子性，所以能保证线程安全；
2. 原子变量可保证原子性，但不能保证可见性，所以不能保证线程安全；
3. volatile变量能保证可见性，但不能保证原子性，所以不能保证线程安全；
4. volatile的原子变量能保证线程安全。

除此之外，还有一些对象一定是线程安全的：
1. 无状态对象；
2. 不可变对象。

但是加锁机制会产生活跃性问题，活跃性问题关注正确的行为是否一定会发生，主要有死锁问题。死锁简单来讲是这样的：线程A持有锁L并想获得锁M，同时线程B持有锁M并想获得锁L，这时线程A和B都永久阻塞。
避免死锁的关键是要保证每个线程获取锁的顺序必须相同，如上面线程A和B获取锁的顺序如果都是先获取锁L再获取锁M，就不会发生死锁问题。
当持有锁时调用外部方法，会很难分析获取锁的顺序，要尽量避免。

编码参考：
1. 将所有可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步；
2. 扩展线程安全的容器类时，在新类中委托容器类的其他方法，使用新锁，不要关心原来的容器类是否线程安全。

参考资料：
《JAVA并发编程实战》

